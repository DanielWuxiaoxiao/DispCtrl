<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1.0, user-scalable=no, width=device-width"
    />
    <script src="./amap/AMap3.js"></script>
    <style>
      /* 设置地图容器的大小 否则地图容器大小为0*/
      #container {
        width: 100%;
        height: 100vh; /* 使容器占满整个视口 */
        margin: 0;
        padding: 0;
        /* 透明度 + 绿色滤镜 */

        /* 重点调整 */
        filter: grayscale(100%) brightness(40%) contrast(200%) sepia(100%)
          hue-rotate(90deg) saturate(300%);
        opacity: 0.9;
        /* grayscale(100%) → 完全去掉原色彩，留下灰度。
        brightness(40%) → 全体压暗，接近黑底。
        contrast(200%) → 增强对比，让线条边界更清晰。
        sepia(100%) hue-rotate(90deg) → 灰度转黄后再旋转色相到绿色。
        saturate(300%) → 提升绿色饱和度，让线条和地块凸显出雷达绿。
        opacity(0.9) → 不完全透明，保持雷达 UI 背景感。 */
      }
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: transparent; /* 背景透明 */
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script src="qwebchannel.js"></script>
    <script type="text/javascript">
      //离线地图
      var initLng = 108.9138;
      var initLat = 34.2311;
      var initRange = 3.0; //km
      var map = new AMap.Map("container", {
        resizeEnable: true,
        center: [initLng, initLat], // 中心点，西电99号楼
        zoom: 15.3, //
        layers: [
          new AMap.TileLayer({
            tileUrl: "./mapNoL/[z]/[x]/[y]/tile.png", // 本地瓦片路径，使用[]而不是{},amap3.js是处理的[]的瓦片替代
            zooms: [1, 16], //注意范围必须大于等于 zoom，瓦片范围为1-16
          }),
        ],
      });

      const earthRadius = 6378.137; // 地球半径，单位为公里

      var mchannel; //注册qt通信通道
      var opacity = 0.35; // 初始透明度
      var greenLevel = 1.0; // 初始绿色程度

      window.onload = function () {
        if (typeof qt != "undefined") {
          new QWebChannel(qt.webChannelTransport, function (channel) {
            channel.objects.qtChannel.centerOn.connect(setCenterOn);
            channel.objects.qtChannel.changeGrayScale.connect(setGrayscale);
            channel.objects.qtChannel.setOpacity.connect(setOpacity);
            channel.objects.qtChannel.setGreenLevel.connect(setGreenLevel);
            mchannel = channel;
          });
        }
      };

      //直接设置地图的中心和距离
      function setCenterOn(centerLng, centerLat, range) {
        // range 是以公里为单位的显示范围（整个水平宽度）
        // 我们需要将这个范围转换为地图四个角的经纬度

        // 使用高精度地球常数
        const EARTH_RADIUS_M = 6378137.0; // WGS84椭球体长半轴，米
        const DEG_TO_RAD = Math.PI / 180.0;
        const RAD_TO_DEG = 180.0 / Math.PI;

        // 动态获取地图容器的实际宽高比
        const container = document.getElementById("container");
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const actualAspectRatio = containerWidth / containerHeight; // 实际宽高比

        console.log(`Container dimensions: ${containerWidth}x${containerHeight}, aspect ratio: ${actualAspectRatio.toFixed(3)}`);

        // 计算水平和垂直的范围，使用实际容器比例
        const horizontalRange = range; // 水平方向的总宽度（公里）
        const verticalRange = range / actualAspectRatio; // 垂直方向的总高度，使用实际宽高比

        // 转换为米
        const horizontalRangeM = horizontalRange * 1000.0;
        const verticalRangeM = verticalRange * 1000.0;

        // 使用高精度公式计算经纬度差异
        const centerLatRad = centerLat * DEG_TO_RAD;

        // 纬度差异：使用精确的子午圈半径计算
        const latDiffRad = (verticalRangeM / 2.0) / EARTH_RADIUS_M;
        const latDiff = latDiffRad * RAD_TO_DEG;

        // 经度差异：考虑椭球体在当前纬度的曲率半径
        const cosLat = Math.cos(centerLatRad);
        const lngDiffRad = (horizontalRangeM / 2.0) / (EARTH_RADIUS_M * cosLat);
        const lngDiff = lngDiffRad * RAD_TO_DEG;

        // 计算矩形边界的西南角和东北角的经纬度
        const southWestLng = centerLng - lngDiff;
        const southWestLat = centerLat - latDiff;
        const northEastLng = centerLng + lngDiff;
        const northEastLat = centerLat + latDiff;

        console.log(`setCenterOn: center(${centerLng}, ${centerLat}), range=${range}km (horizontal)`);
        console.log(`Calculated ranges: horizontal=${horizontalRange}km, vertical=${verticalRange.toFixed(3)}km`);
        console.log(`Calculated bounds: SW(${southWestLng.toFixed(8)}, ${southWestLat.toFixed(8)}), NE(${northEastLng.toFixed(8)}, ${northEastLat.toFixed(8)})`);
        console.log(`High-precision diffs: lat=${latDiff.toFixed(8)}°, lng=${lngDiff.toFixed(8)}°`);

        var bounds = new AMap.Bounds(
          [southWestLng, southWestLat], // 西南角坐标
          [northEastLng, northEastLat] // 东北角坐标
        );
        // 设置地图显示的边界范围
        map.setBounds(bounds);
      }
      //如果再setcenter后立即执行getcenter函数会导致setcenter实际没有完全更新地图，这个时候获得的center并不是最终center
      setCenterOn(initLng, initLat, initRange);

      // 透明度调整 (0.0~1.0)
      function setOpacity(value) {
        opacity = Math.max(0, Math.min(1, value));
        applyFilter(70, opacity, greenLevel);
      }

      // 绿色程度调整 (0.0~2.0，越大越绿)
      function setGreenLevel(value) {
        greenLevel = Math.max(0, Math.min(2.0, value));
        applyFilter(70, opacity, greenLevel);
      }

      // 应用滤镜
      function applyFilter(gray, op, green) {
        var container = document.getElementById("container");
        container.style.opacity = op;

        container.style.filter =
          `grayscale(${gray}%) brightness(80%) contrast(90%) ` +
          `sepia(60%) hue-rotate(90deg) saturate(${100 + green * 50}%)`;
      }
    </script>
  </body>
</html>
